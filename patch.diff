diff --git a/internal/http/handlers.go b/internal/http/handlers.go
index 1234567..89abcdef 1
--- a/internal/http/handlers.go
+++ b/internal/http/handlers.go
@@ -1228,7 +1228,7 @@ func (s *Server) GetVideo(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	resp, err := s.videoService.GetVideoDirect(r.Context(), claims.UserID, claims.OrgID, videoID)
+	resp, err := s.videoService.GetVideoDirect(r.Context(), claims.UserID, claims.OrgID, claims.Role, videoID)
 	if err != nil {
 		// Check error type and return appropriate HTTP status
 		errorMsg := err.Error()
@@ -1479,7 +1479,7 @@ func (s *Server) DownloadVideo(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	resp, err := s.videoService.GetPrivateDownloadURL(r.Context(), claims.UserID, claims.OrgID, videoID)
+	resp, err := s.videoService.GetPrivateDownloadURL(r.Context(), claims.UserID, claims.OrgID, claims.Role, videoID)
 	if err != nil {
 		s.auditService.LogAction(r.Context(), claims.UserID, claims.OrgID, models.AuditVideoDownloadPrivate, models.AuditResultFailure, ipAddress, userAgent, map[string]interface{}{
 			"video_id": videoID,
diff --git a/internal/video/service.go b/internal/video/service.go
index abcdef1..2345678 1
--- a/internal/video/service.go
+++ b/internal/video/service.go
@@ -260,13 +260,17 @@ type CompleteMultipartUploadResult struct {
 }
 
 // GetVideoDirect gets video information with direct parameters
-func (s *Service) GetVideoDirect(ctx context.Context, userID, orgID, videoID string) (*VideoInfo, error) {
+func (s *Service) GetVideoDirect(ctx context.Context, userID, orgID, role, videoID string) (*VideoInfo, error) {
 	video, err := s.db.GetVideo(ctx, videoID)
 	if err != nil {
 		return nil, err
 	}
 	if video.OrgID != orgID {
 		return nil, fmt.Errorf("access denied")
 	}
+
+	if rbac.Role(role) == rbac.RoleUser && video.UploadedBy != userID {
+		return nil, fmt.Errorf("access denied")
+	}
 
 	var uploadedAt int64
 	if video.UploadedAt != nil {
@@ -435,13 +439,17 @@ func (s *Service) SearchVideosDirect(ctx context.Context, userID, orgID, role, q
 }
 
 // GetPrivateDownloadURL генерирует временный URL для скачивания приватного видео
-func (s *Service) GetPrivateDownloadURL(ctx context.Context, userID, orgID, videoID string) (*models.DownloadURLResult, error) {
+func (s *Service) GetPrivateDownloadURL(ctx context.Context, userID, orgID, role, videoID string) (*models.DownloadURLResult, error) {
 	video, err := s.db.GetVideo(ctx, videoID)
 	if err != nil {
 		return nil, fmt.Errorf("video not found")
 	}
 
 	if video.OrgID != orgID {
 		return nil, fmt.Errorf("access denied")
 	}
+
+	if rbac.Role(role) == rbac.RoleUser && video.UploadedBy != userID {
+		return nil, fmt.Errorf("access denied")
+	}
 
 	// Генерируем временный URL на приватный bucket (1 час)
 	url, err := s.storage.GeneratePresignedDownloadURL(ctx, video.StoragePath, 1*time.Hour)