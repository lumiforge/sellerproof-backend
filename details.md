Для Фазы 2 с ролями admin, manager и user рекомендуется использовать подробный и чёткий список разрешений, который отражает ваши требования и обеспечивает надёжную RBAC-систему.

***

## Предложение по разрешениям для каждой роли

| Операция                         | admin               | manager                         | user                   |
|---------------------------------|---------------------|--------------------------------|------------------------|
| Просмотр списка всех видео       | ✅                  | ✅ (в своей организации)        | ✅ (в своей организации)|
| Загрузка видео                  | ✅                  | ✅ (в своей организации)        | ❌                     |
| Удаление видео                 | ✅                  | ✅ (в своей организации)        | ❌                     |
| Просмотр деталей видео          | ✅                  | ✅ (в своей организации)        | ✅                     |
| Скачивание видео               | ✅                  | ✅ (в своей организации)        | ✅                     |
| Создание публичных ссылок (sharing) | ✅              | ✅ (в своей организации)        | ❌                     |
| Отзыв публичных ссылок           | ✅                  | ✅ (в своей организации)        | ❌                     |
| Управление пользователями организации | ✅              | ✅ (в своей организации)        | ❌                     |
| Создание и управление организациями        | ✅              | ❌                             | ❌                     |
| Управление ролями пользователей в организации | ✅              | ✅ (в своей организации)        | ❌                     |
| Просмотр журналов аудита          | ✅                  | ✅                             | ❌                     |
| Администрирование подписок        | ✅                  | ❌                             | ❌                     |

***

## Обоснование и детали

- **admin** — суперпользователь с полным доступом, управляет организациями, пользователями и видео. Может создавать новые организации, назначать роли, просматривать аудиты и управлять подписками.
- **manager** — отвечает за управление видео и пользователями в рамках своей организации. Может загружать, удалять видео, создавать публичные ссылки для обмена, и изменять роли пользователей в своей организации.
- **user** — базовая роль с возможностью только просматривать и скачивать видео. Публичные ссылки создавать не может, управлять видео нельзя.

***

## Дополнительные аспекты

- Разрешения должны проверяться в каждом gRPC-запросе через Cloud Function на основе JWT токена и membership из YDB.
- RBAC логику удобно реализовать централизованно, например, функцию checkPermission(ctx, userID, orgID, action).
- Возможна в будущем детализация ролей или добавление новых, например, viewer-only, uploader, администратор биллинга и т.п.

Это предложение покрывает большинство сценариев с контролем доступа, обеспечивает изоляцию данных между организациями и соответствует указанным требованиям.

Для реализации RBAC в вашем сервисе SellerProof оптимально использовать следующий формат JWT токена:

***

## Рекомендуемая структура JWT токена

### Standard Claims:
- **sub** — уникальный идентификатор пользователя (user_id)
- **exp** — время истечения токена
- **iat** — время создания токена

### Custom Claims:
- **user_id** — UUID пользователя (для удобства использования в сервисах)
- **email** — email пользователя
- **role** — роль в организации (admin, manager, user)
- **org_id** — идентификатор организации (tenant isolation)

***

## Обоснование выбора

- **Минимальный подход с user_id, email, role, org_id** обеспечивает компактность токена.
- Более детальные данные (например permissions, membership_id) можно получать динамически из YDB при необходимости, что позволяет централизованно управлять ролями/правами.
- Такой подход упрощает обновление прав — не нужно реиздавать токен при изменении разрешений, только меняется данные в базе.
- Claims достаточно для быстрого RBAC решения в Cloud Functions — роль и org_id указывают контекст и права доступа.

***

## Пример структуры JWT Claims (JSON):

```json
{
  "sub": "123e4567-e89b-12d3-a456-426614174000",
  "user_id": "123e4567-e89b-12d3-a456-426614174000",
  "email": "user@example.com",
  "role": "manager",
  "org_id": "org-987654321",
  "exp": 1700365678,
  "iat": 1700362078
}
```

***

## Реализация проверки в Cloud Function

При получении запроса по JWT от клиента:

- Проверять валидность токена по секрету
- Декодировать claims
- Использовать **role** и **org_id** для принятия решений в RBAC (например, разрешение на загрузку видео только если роль подходит)

***

Этот подход — компромисс между безопасностью, компактностью токена и удобством в распределённой среде с YDB.[1]

[1](https://yandex.cloud/en/docs/functions/functions/api-ref/grpc/)

Для управления подписками в SellerProof рекомендуется использовать более продвинутую структуру, учитывающую историю подписок и отдельную таблицу с тарифными планами. Такой подход обеспечивает гибкость и удобство управления.

***

## Рекомендуемая структура таблиц

### 1. Таблица `plans` (тарифные планы)

| Поле             | Тип       | Описание                                     |
|------------------|-----------|----------------------------------------------|
| plan_id          | String    | Уникальный идентификатор плана                |
| name             | String    | Наименование (free, pro, enterprise)           |
| storage_limit_gb | Int64     | Лимит по месту хранения                         |
| video_count_limit| Int64     | Лимит по количеству видео (если нужен)         |
| price_rub        | Decimal   | Цена за период                                 |
| billing_cycle    | String    | Период оплаты (monthly, yearly)                |
| features         | JSON      | Дополнительные возможности (например, sharing)|
| created_at       | Timestamp | Дата создания                                  |
| updated_at       | Timestamp | Дата обновления                                |

***

### 2. Таблица `subscriptions` (активные подписки)

| Поле              | Тип       | Описание                                    |
|-------------------|-----------|---------------------------------------------|
| subscription_id   | String    | Уникальный ID подписки                       |
| user_id           | String    | Владелец подписки (FK to users)              |
| org_id            | String    | Организация/тенант                           |
| plan_id           | String    | Текущий тариф (FK to plans)                   |
| storage_limit_gb  | Int64     | Лимит хранения, копируется из плана          |
| video_count_limit | Int64     | Лимит количества видео                         |
| is_active         | Bool      | Флаг активности подписки                      |
| trial_ends_at     | Timestamp | Окончание пробного периода                    |
| started_at        | Timestamp | Дата начала подписки                          |
| expires_at        | Timestamp | Дата окончания/прекращения                    |
| billing_cycle     | String    | Период оплаты, для удобства                   |
| created_at        | Timestamp | Дата создания                                |
| updated_at        | Timestamp | Дата последнего обновления                    |

***

### 3. Таблица `subscription_history` (архив изменений подписок)

| Поле              | Тип       | Описание                                      |
|-------------------|-----------|-----------------------------------------------|
| history_id        | String    | Уникальный идентификатор записи                |
| subscription_id   | String    | Подписка, к которой относится запись            |
| plan_id           | String    | Тариф в момент записи                           |
| storage_limit_gb  | Int64     | Лимит в момент записи                           |
| video_count_limit | Int64     | Лимит количества видео                          |
| event_type        | String    | Событие (created, upgraded, downgraded, canceled)|
| changed_at        | Timestamp | Время изменения                                |

***

## Обоснование

- Таблица `plans` позволяет централизованно управлять тарифами, менять цены, лимиты и функции.
- Таблица `subscriptions` содержит текущее состояние подписок пользователя и организации (например, multi-tenancy).
- Таблица `subscription_history` удобна для аудита и анализа, позволяет видеть, когда и какие изменения происходили.
- Включение `org_id` поддерживает multi-tenancy и разграничение подписок по организациям.
- Поля `storage_limit_gb` и `video_count_limit` дублируются из `plans` для быстрой проверки лимитов без сложных join-операций.

***

## Пример SQL для `subscriptions`

```sql
CREATE TABLE subscriptions (
    subscription_id String PRIMARY KEY,
    user_id String,
    org_id String,
    plan_id String,
    storage_limit_gb Int64,
    video_count_limit Int64,
    is_active Bool,
    trial_ends_at Timestamp,
    started_at Timestamp,
    expires_at Timestamp,
    billing_cycle String,
    created_at Timestamp,
    updated_at Timestamp,
    INDEX user_idx GLOBAL ON (user_id),
    INDEX org_idx GLOBAL ON (org_id)
);
```

***

Такой подход позволит гибко управлять подписками вашего сервиса с масштабируемостью и удобством анализа.

Для организации пользователей и управления их ролями в рамках организаций рекомендуется использовать структуру с разделением информации об организациях и членстве (membership), которая обеспечивает гибкость, поддержку приглашений и статусов.

***

## Рекомендуемая структура таблиц

### 1. Таблица `organizations`

| Поле         | Тип      | Описание                        |
|--------------|----------|--------------------------------|
| org_id       | String   | Уникальный идентификатор организации |
| name         | String   | Название организации           |
| owner_id     | String   | Владелец (user_id) организации |
| settings     | JSON     | Настройки организации (опционально) |
| created_at   | Timestamp| Дата создания                 |
| updated_at   | Timestamp| Дата обновления               |

***

### 2. Таблица `memberships`

| Поле          | Тип      | Описание                                              |
|---------------|----------|-------------------------------------------------------|
| membership_id | String   | Уникальный идентификатор записи                       |
| user_id       | String   | Идентификатор пользователя                            |
| org_id        | String   | Идентификатор организации                             |
| role          | String   | Роль (admin, manager, user и т.п.)                    |
| status        | String   | Статус участия (active, invited, declined)            |
| invited_by    | String   | Кто пригласил (user_id) (nullable)                    |
| created_at    | Timestamp| Дата создания записи                                  |
| updated_at    | Timestamp| Дата последнего обновления                            |

***

## Обоснование выбора

- **organizations** хранит основные данные организации и владельца (owner) для контроля прав.
- **memberships** служит для управления связями пользователей и организаций, поддерживает роли и статусы приглашений.
- Поле **settings** в организациях позволяет гибко хранить дополнительные параметры и настройки.
- Статусы в memberships позволяют реализовать систему приглашений с подтверждением и возможностью отклонения.
- Информация об **invited_by** позволяет отслеживать, кто пригласил пользователя в организацию.

***

## Пример SQL для memberships

```sql
CREATE TABLE memberships (
    membership_id String PRIMARY KEY,
    user_id String,
    org_id String,
    role String,
    status String,
    invited_by String,
    created_at Timestamp,
    updated_at Timestamp,
    INDEX user_idx GLOBAL ON (user_id),
    INDEX org_idx GLOBAL ON (org_id)
);
```

***

Такой дизайн таблиц облегчает управление организационной структурой, ролями пользователей, приглашениями и поддерживает audit trail изменений статусов и ролей.

Для вашего сервиса SellerProof рекомендуем использовать комбинированный подход верификации email, который обеспечивает удобство и безопасность.

***

## Рекомендуемый способ верификации email

### Комбинация

- **Отправка 6-значного кода на email**  
  Пользователь получает код и вручную вводит его в приложении для подтверждения владения адресом. Это стандартный и понятный способ, хорошо защищённый от случайной активации.

- **Резервная уникальная ссылка с токеном**  
  В письме также содержится ссылка, при переходе по которой верификация происходит автоматически. Это удобно для пользователей, которые предпочитают клики вместо ввода кода.

***

## Дополнительно: Magic Link (опционально)

- Можно предусмотреть магическую ссылку, которая после верификации автоматически логинит пользователя, повышая UX.  
- Для максимальной безопасности магические ссылки должны иметь короткий срок жизни (например, 15 минут).

***

## Пример процесса

1. Пользователь регистрируется в приложении, вводит email.
2. Система генерирует 6-значный код и уникальный токен.
3. Письмо с кодом и ссылкой отправляется через Yandex Cloud Postbox.
4. Пользователь вводит код в приложении **или** нажимает на ссылку в письме.
5. Сервер проверяет код или токен, обновляет в YDB статус email_verified.

***

## Преимущества

- Повышение конверсии верификации за счёт выбора способа пользователем.
- Баланс удобства и безопасности.
- Легко реализуется с использованием Postbox, сохраняет логи отправленных email.

Такой комбинированный подход — лучший вариант для качественного и удобного подтверждения email в вашем сервисе.[1][2]

[1](https://yandex.cloud/ru/services/postbox)
[2](https://yandex.cloud/en/docs/tutorials/serverless/postbox-webhook)

Для вашего сервиса SellerProof на Yandex Cloud оптимально использовать стандартную Go структуру с разделением по пакетам внутри одного монолитного проекта. 

***

## Рекомендуемая структура проекта

### Стандартная Go структура с внутренними пакетами (internal/)

```
sellerproof-backend/
├── cmd/
│   └── main.go              # Точка входа (Cloud Function handler)
├── internal/
│   ├── auth/                # JWT, регистрация, логин, email verification
│   ├── rbac/                # Проверка ролей и прав доступа
│   ├── storage/             # Object Storage: presigned URLs, multipart upload
│   ├── email/               # Отправка почты через Postbox
│   ├── ydb/                 # Интерфейсы и реализации работы с базой YDB
│   ├── payment/             # Интеграция с Тинькофф (инициация и обработка платежей)
│   ├── logger/              # Логирование и интеграция с Telegram
│   └── grpc/                # gRPC сервер и protobuf генерированные файлы
├── pkg/                     # Вспомогательные библиотеки и утилиты (если нужны)
├── Makefile                 # Сценарии сборки и деплоя
├── go.mod                   # Модули и зависимости
└── .env.example             # Описание переменных окружения
```

***

## Почему именно так?

- Удобство разработки и поддержки благодаря модульности пакетов.
- Безопасность: `internal/` гарантирует инкапсуляцию компонентов внутри проекта.
- Простое деплоирование как одного сервиса (Cloud Function), без оверхеда управления микросервисами.
- Легкость тестирования модулей отдельно.
- Чёткое разделение ответственности: каждый пакет отвечает за собственную бизнес-логику.
- При необходимости можно в будущем перейти к микросервисам, выделив пакеты в отдельные сервисы.

***

## Альтернативы и их ограничения

- **Монолит с одним пакетом** — быстро, но сложнее масштабировать и поддерживать.
- **Domain-driven дизайн** — подходит для крупных и сложных систем, сейчас избыточно.
- **Микросервисы** — для MVP усложняет инфраструктуру и деплой; рекомендован для масштабирования позже.

***

Таким образом, структура с папкой `internal` и ясным разделением по компонентам — это разумный баланс удобства и архитектурной чистоты для вашего проекта на Go и Yandex Cloud.